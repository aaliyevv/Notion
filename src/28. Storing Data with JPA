# #28. Storing Data with JPA

- What is the **JPA**

    The Java Persistence API (JPA) is a **specification** (set of rules) for managing the relationship between Java applications and relational databases. In simple terms, it helps you "translate" (map) your object-oriented Java code (objects) directly to database tables.

    This process is called **ORM (Object-Relational Mapping)**. JPA itself does not work directly; it is just an interface. Behind it is a "persistence provider" such as **Hibernate** or **EclipseLink** that does the real work.

- Why JPA
    - **Independence:** It is easier to change the database (for example, from MySQL to PostgreSQL).
    - **Productivity:** Instead of writing SQL queries directly, you work with Java objects, which makes the code more readable and manageable.
    - **Standardization:** Provides a unified approach to working with data in the Java ecosystem.
- Entity Mapping

    A Java class that corresponds to a table in a database is called an Entity. We use special annotations to tell JPA that this class is a table.

- Main Annotations
    - `@Entity`: Indicates that this class is a database entity.
    - `@Table(name = "users")`: (Optional) Indicates the table name if the table name is different from the class name.
    - `@Id`: Indicates that this field is the primary key in the table.
    - `@GeneratedValue(strategy = GenerationType.IDENTITY)`: Indicates that the value of the `@Id` field will be automatically generated by the database (e.g., auto-increment).
    - `@Column(name = "user_name")`: (Optional) Indicates the column name if the field name is different from the column name in the table.
- Example (Entity)

    ![image.png](attachment:939d736a-f33a-499e-97a6-147173adffcd:image.png)

- CRUD Operations

    In JPA, we perform basic operations through the `EntityManager` object. In frameworks like Spring, this process is further automated.

    - **Persistence Context:** A collection of objects (a kind of cache) managed by the `EntityManager`, which is synchronized with the database.

    All changes (Create, Update, Delete) must occur within a **transaction**. In Spring, this is usually handled with the `@Transactional` annotation.

    The following examples show how the `EntityManager` works:

    - Create

        The persist() method adds the object to the "persistence context" and writes it to the database when the transaction completes.

        ![image.png](attachment:abfedbed-2508-4243-93f4-f36a6bc43e9e:image.png)

    - Read

        The find() method finds the object with the given Id directly from the database (or context).

        ![image.png](attachment:41154211-3b2c-4dec-97ab-57a867b62670:image.png)

    - Update

        JPA does not have a direct "update" method. When you find an object with find() and bring it into the context, it is put into a "managed" state. If you call any setter on that object within a transaction, JPA will automatically update the changes in the database when the transaction ends.

        ![image.png](attachment:274beb1b-d5c5-4747-b858-86f94c0d725f:image.png)

    - Delete

        The remove() method removes the object from the context and from the database when the transaction ends.

        ![image.png](attachment:3fb8880e-0d1a-45a3-95d7-b40fb9ec5c25:image.png)

- Repository Usage (with Spring Data JPA)

    Working directly with the `EntityManager` can sometimes be very detailed. **Spring Data JPA** simplifies this process dramatically.

    **Repository** is a design pattern that encapsulates methods for working with databases.

    In Spring Data JPA, you simply create an **interface** and extend it from `JpaRepository`. Spring automatically implements all the CRUD operations for you.

- Example (Repo)

    Create only an interface

    ![image.png](attachment:6de6c81f-83be-49ca-a94c-503c7d605d21:image.png)

- Example (Service)

    ![image.png](attachment:a23566a1-8fb1-433e-866b-0be1eb5ec224:image.png)

- Example (Repo with query)

    ![image.png](attachment:dc027129-230b-4c39-a118-9d9dca83b6c1:image.png)