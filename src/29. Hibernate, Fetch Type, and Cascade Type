# #29. Hibernate, Fetch Type, and Cascade Type

- **Summary**
    1. **CascadeType.PERSIST**: Save `User` and associated `Order` automatically.
    2. **CascadeType.MERGE**: Update `User` and associated `Order`.
    3. **CascadeType.REMOVE**: Delete `User` and associated `Order`.
    4. **FetchType.LAZY**: Load `User` without loading `Order` until explicitly accessed.
    5. **FetchType.EAGER**: Load `User` and `Order` together immediately.
    6. **CascadeType.ALL**: Combination of all cascade types (save, update, delete).

### Cascade

- **CascadeType.PERSIST**

    When `CascadeType.PERSIST` is applied, saving (persisting) the parent entity will also save its related child entities (like user and his order).

    ![image.png](attachment:d41d9387-79c4-452a-b193-1fe9d84ebcff:image.png)

    **Expected Behavior**: The `User` and its `Order` entities should be saved together in the database.

- **CascadeType.MERGE**

    When `CascadeType.MERGE` is applied, updating a parent entity will also update the child entities.

    **Expected Behavior**: The `User` should be updated with the new name, and the `Order` should also be updated to reflect the new order details.

- **CascadeType.REMOVE**

    When `CascadeType.REMOVE` is applied, deleting the parent entity will also delete the child entities.

    **Expected Behavior**: Both the `User` and the associated `Order` should be deleted from the database.

    - **`orphanRemoval = true`**

        `orphanRemoval = true`:If you simply do `author.getBooks().remove(book)` and then save the author (i.e. remove the book from the Author list, but do not call `bookRepository.delete()`, JPA will see that this Book is "orphaned" and will automatically delete it from the database.

- **CascadeType.ALL**

    This is a combination of all cascade types (`PERSIST`, `MERGE`, `REMOVE`, etc.). It means that any operation (save, update, delete) on the parent entity will also be applied to the child entities.

    **Expected Behavior**: The `User` and all its associated `Order` entities should be created, updated, and deleted together.


### FetchType

- **FetchType.LAZY**

    We will load a `User` without loading the associated `Order` entities unless they are explicitly accessed.

    **Expected Behavior**: The response should only contain the `User` details without the `Order` entities (since `FetchType.LAZY` means orders are not fetched automatically).

- **FetchType.EAGER**

    When `FetchType.EAGER` is applied, related entities are fetched immediately when the parent entity is loaded.

    **Expected Behavior**: The response should include both the `User` details and the associated `Order` entities (since `FetchType.EAGER` means the orders are eagerly loaded).

- **Default FetchType**

    If a right side is a little bit, then it treat as an eager type, if more treats as a lazy type as a default mode.

    ![image.png](attachment:63f113f4-fe6b-4fa1-9b93-398cf2587ba0:image.png)

- Fetching data

    fetch = FetchType.LAZY - I need department info not dependent datas such as employees. (OneToMany)

    fetch = FetchType.EAGER - fetches department and its dependents. (most usage: @ManyToOne, @OneToOne)


### Mentor Notes

- Key Concept: Owning Side

    In bidirectional relationships (for example, both `Author` has a `Book` list and `Book` has an `Author` object), JPA needs to know which side controls the relationship.

    - **Owning Side:** The side that corresponds to the table in the database that holds the foreign key. Usually, the `@ManyToOne` side is the owner. This side creates and deletes the relationship.
        - **`@JoinColumn` Annotation Parameters**
            - **Explanation:** This annotation indicates that we are the "owner" of the relationship and that the foreign key is in this table (the `Book` table).
            - **Inverse Side:** The side that does not hold the foreign key. This side simply "mirrors" the relationship and uses the `mappedBy` parameter.
    - Inverse Side: The side that does not hold the foreign key. This side simply "mirrors" the relationship and uses the mappedBy parameter.

    @OneToMany (mappedBy = “department”) - there is a dependent side managed by department. Without this parameter, JPA will assume there are two relationships and try to create an intermediate table (author_books), which is incorrect.

- Example: `@OneToMany`

    ### `Author.java` (Inverse Side)

    ![image.png](attachment:1527e91f-25e9-49eb-ba15-4a5501e5b29f:image.png)

    ### `Book.java` (Owning Side)

    ![image.png](attachment:f25ce3dc-ba2e-4d21-83cb-4931b47a0b8f:image.png)

- Example: `@OneToOne`

    ### `User.java` (Inverse Side)

    ![image.png](attachment:5294c6dd-a4c2-409a-9eb0-9f1678a682b5:image.png)

    // User-dən profili ayırsaq (user.setProfile(null)), profil bazadan silinsin

    ### `UserProfile.java` (Sahib Tərəf / Owning Side)

    ![image.png](attachment:2b316b0c-56ab-4074-83be-f8a1e05924e3:image.png)

- Example: `@ManyToMany`

    This relationship cannot be established directly between two tables. A third Join Table is required. This table stores the primary keys of both tables as foreign keys.

    ### `Student.java` (Owning Side)

    ![image.png](attachment:7a6a8ef7-47c5-43e7-aabb-6afcd3be0d25:image.png)

    **`inverseJoinColumns = @JoinColumn(name = "course_id")`**: Specifies the name of the column in the intermediate table that refers to the "opposite" side (i.e. `Course`).

    ![image.png](attachment:93f34a68-d8a8-4347-bb6b-4bd94192c070:image.png)

    **`mappedBy = "courses"`**: Required. It means "I don't own this relationship. The relationship is managed by the `courses` field in the `Student` class. All the intermediate table configuration is there.”

- Relation
    - class → table
    - field → column
    - `@Id` → primary key
    - `@GeneratedValue` → auto-increment
- How to treat dependent datas

    cascade = CascadeType.ALL (instead of all we can write merge - update all dependent classes, persist - save dependets also, remove - delete dependents). If we want to delete department id I mean main part it gives us error because of dependent datas are available. First of all, we should delete dependent datas, that is why we use .ALL .

- Best Practices
    1. **`@OneToOne`:**
    - Always try to use `fetch = FetchType.LAZY`.
    - `cascade = CascadeType.ALL` and `orphanRemoval = true` are very useful for parent-child relationships (e.g. `UserUserProfile`).
    1. **`@ManyToMany`:**
    - Always use `fetch = FetchType.LAZY` (the default).
    - Do not use `CascadeType.REMOVE` or `ALL`, as this can cause unexpected data loss.
    - **Alternative:** Often, instead of using the `@ManyToMany` relationship directly, it is better to create the intermediate table as an Entity (`Enrollment`). This allows us to add additional data (e.g. `registration_date`, `grade`) to the intermediate table. In this case, the relationship becomes two `@OneToMany` relationships ( `Student` -> `Enrollment` and `Course` -> `Enrollment`).