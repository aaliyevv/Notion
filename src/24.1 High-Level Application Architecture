# #24.1 High-Level Application Architecture (1)

- **Overview**

    ![image.png](attachment:839071ce-209f-44f7-af7b-fc3c1f6c9d6f:image.png)

- **Developer's Perspective**
    - As developers, we write code, and this code needs to be deployed to a server.
    - **What is a server?** For now, let's assume it's a computer that handles requests and serves users. We'll explore this further later in the course.
- **Code Deployment Process**
    - Before the code reaches the server, it usually goes through a build and deploy phase. This could happen on a developer's local machine or more commonly on a **CI/CD (Continuous Integration/Continuous Deployment)** server.
    - **CI/CD servers** are frequently used in professional production-grade applications to automate the build and deployment process.
- **Server and Storage**
    - A server will need to **store data** using some kind of external storage mechanism, which could be a database or other storage forms.
    - This storage is assumed to be **distributed** and located separately from the server. The server connects to the storage over a network.
- **User's Perspective**
    - From an external user’s perspective, they interact with our server via requests, usually from their browser.
    - The server might respond with front-end code (HTML, JavaScript) or handle requests through an API that returns data (often in JSON format).
- **Scaling the System**
    - **Vertical Scaling**

        If a single server can't handle all requests, we can upgrade its hardware (CPU, RAM, disk) to handle more traffic. This is called **vertical scaling**.

    - **Horizontal Scaling**

        However, there are limits to vertical scaling. So, we can use **horizontal scaling**, where multiple copies of the server handle requests. This prevents a single server from becoming a bottleneck.

- **Load Balancing**

    With multiple servers, we need a **load balancer** to distribute traffic evenly. The load balancer ensures that no single server handles too much traffic while others remain idle.

- **Inter-server Communication**

    Servers often need to communicate with other external servers. For example, an app like [NeatCode.io](http://neatcode.io/) communicates with services like the **Stripe API** for payments.

- **Logging and Monitoring**
    - **Logging**

        Servers generate **logs** that developers use to understand system performance or troubleshoot issues. These logs are usually stored in an external logging service.

    - **Metrics**

        In addition to logs, we need insight into how our server is performing in terms of CPU usage, memory, and other resources. For this, we use a **metrics service**.

    - **Alerting**

        Metrics can trigger **alerts**. For example, if successful user requests drop below a threshold (e.g., 95%), an alert notifies developers immediately.

- **Networking and Communication**
    - These components (servers, storage, logs, etc.) don’t always run on the same machine, so they communicate over a network.
    - Understanding the basics of **networking** is essential to designing large-scale applications. Networking allows these distributed components to work together seamlessly.
- **Conclusion**

    This lesson has provided an overview of high-level application architecture. Over the next lessons, we’ll dive deeper into each of these components and explore more complex concepts, such as networking, scaling strategies, and performance optimization.

- **Notes**
    - **Vertical Scaling**: Improving a single server’s hardware.
    - **Horizontal Scaling**: Adding more servers to handle traffic.
    - **Load Balancing**: Distributing traffic across multiple servers.
    - **Logging and Metrics**: Tools for monitoring server performance.
    - **Alerting**: Automatic notifications when performance issues arise.
    - **Networking**: Enables communication between distributed system components.