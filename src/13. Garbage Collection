# **#13** Garbage Collection

- **Java Memory Model Overview**

    Generally JVM memory  contains **Main Memory (Heap + Stack + Metaspace)**. Java uses **Heap Memory**
     for dynamic memory allocation. Garbage Collector (GC)  manages objects inside Heap. In stack When a
     method finishes executing, its frame is automatically removed from the stack. GC does not work here.
      **Burada GC işləmir.** Java heap memory is divided into different sections:

    Young Generation (Eden Space (New Object Creation) and Survivor Spaces) → Old Generation and Metaspace
    (Metadata)

    Long-living objects are moved to Old Generation after multiple GC cycles but after one GC cycle moved
    to **Survivor Spaces**

    ![image.png](attachment:0f765170-6aea-41e2-acb7-d94db8501f7c:image.png)

    Metadata (older name was PermGen): is not data itself, data about the data. For instance picture and
    the date when that picture was taken. The space of the Metadata is more permanent than others. PermGen:
     Permanent Generation

    GC mostly and often cleans up this small Young Generation space(Minor GC).

    When the Older Generation is full, the slower and more comprehensive Major GC is launched.

- **Importance of  Garbage Collection**
    - Improves application performance(reduce **memory leaks)**
    - Reduces the risk of `OutOfMemoryError` (JVM cant allocate a place for an object)
    - Simplifies memory management for developers(Unlike C++, programmer does not have to manually clean up
     memory)

- **Garbage Collection Process**

    1. **Mark Phase**: Identifies reachable(referenced) objects(marks as “live”).
    2. **Sweep Phase**: Removes unreferenced objects.
    3. **Compaction Phase**: Organizes memory by moving surviving objects closer together to reduce
    fragmentation.

    **Fragmentation**: Inefficient use of memory due to the allocation and deallocation of objects over
    time. This process leaves "gaps" or small, non-contiguous blocks of free memory spreaded throughout
    the heap. GC might need to work harder and more frequently to find suitable free blocks for new object
     allocations.

- **Objects that Eligible for GC**

    - Setting objects to `null`.
    - When an object no longer has references pointing to it or assigning a reference to another object.
    - Explicitly calling `System.gc()` (not recommended).

- **Default Garbage Collector in Java**

    The **default garbage collector** in Java depends on the **JDK version** and **JVM settings**:

    - **Java 8 and earlier** → **Parallel GC**
    - **Java 9 to 14** → **G1GC**
    - **Java 15 and later** → **G1GC (can also use ZGC or Shenandoah)**

    You can check the default GC used by the JVM with:

    java -XX:+PrintCommandLineFlags -version

- **Garbage Collector Hierarchy**

    **Serial GC → Parallel GC (Throughput GC) → G1GC (Garbage First GC Java 9+) →ZGC (Z Garbage Collector
    Java 11+)**

    **Serial GC** - like one worker is busy cleaning, while the others are waiting.

    **Parallel GC** - multiple workers can work simultaneously.

    **G1GC** - uses both resources and GC on average.

    **ZGC** - the most ideal option with low latency,  the code will run quickly thanks to a lot of
     resources and workers.

- **finalize()**

    When we call System.gc(), it searches finalize method. In Java, it is a method that is called before
     an object is deleted by garbage collection. It has been outdated since Java 9.

    - can significantly degrade performance
    - not guaranteed
    - more recommended to use `Cleaner` və `PhantomReference` for Java 9+.

- **StringBuilder vs String**

    1. `String` in Java is immutable(unchangeable). But `StringBuilder` mutable class. It makes changes
     to existing text, does not create a new object, and is faster.
    2. When we use concatenation time complexity of `String` is O(n²) but `StringBuilder` is O(n).
    3. Large string concatenation uses a lot of RAM.
    4. If a lot of `string +=` is used, GC Garbage Collector has to run frequently, which degrades
     performance.

    StringBuffer is used for multi-threaded operations, but StringBuilder is used for single-threaded
    tasks(synchronized).

- **How StringBuilder is work?**

    1. creates internal buffer
    2. saves the text in buffer
    3. When you add new text with `append()` or `insert()` , it modifies that buffer without creating a new object.

    ![image.png](attachment:39af680d-f76d-47df-bc06-4304e20aa102:image.png)

    ![image.png](attachment:cf53453d-618d-4adb-84a1-08829dc14f9c:image.png)